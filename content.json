{"meta":{"title":"BHK","subtitle":"","description":"","author":"linkfo","url":"https://linkfo.github.io","root":"/"},"pages":[{"title":"about","date":"2023-07-10T05:56:24.000Z","updated":"2023-07-10T05:56:24.214Z","comments":true,"path":"about/index.html","permalink":"https://linkfo.github.io/about/index.html","excerpt":"","text":""},{"title":"书单","date":"2023-08-03T13:11:39.833Z","updated":"2023-08-03T13:11:39.833Z","comments":false,"path":"books/index.html","permalink":"https://linkfo.github.io/books/index.html","excerpt":"","text":""},{"title":"categories","date":"2023-07-10T05:56:51.000Z","updated":"2023-07-20T07:22:12.220Z","comments":true,"path":"categories/index.html","permalink":"https://linkfo.github.io/categories/index.html","excerpt":"","text":""},{"title":"index","date":"2023-07-21T13:09:43.000Z","updated":"2023-08-03T13:25:03.792Z","comments":true,"path":"index/index.html","permalink":"https://linkfo.github.io/index/index.html","excerpt":"首页 标注完整的读书笔记","text":"进行中 [[python for data analysis]] 已完成 待做"},{"title":"list","date":"2023-07-10T05:57:02.000Z","updated":"2023-07-10T05:57:02.822Z","comments":true,"path":"list/index.html","permalink":"https://linkfo.github.io/list/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2023-07-10T04:51:50.039Z","updated":"2023-07-10T04:51:50.039Z","comments":true,"path":"links/index.html","permalink":"https://linkfo.github.io/links/index.html","excerpt":"","text":""},{"title":"tags","date":"2023-07-10T05:56:38.000Z","updated":"2023-07-20T07:21:45.161Z","comments":true,"path":"tags/index.html","permalink":"https://linkfo.github.io/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2023-07-20T07:22:05.184Z","updated":"2023-07-20T07:22:05.184Z","comments":false,"path":"repository/index.html","permalink":"https://linkfo.github.io/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"编程渣渣翻译详解","slug":"编程渣渣翻译详解","date":"2023-08-03T12:52:46.000Z","updated":"2023-08-03T13:38:07.457Z","comments":true,"path":"2023/08/03/编程渣渣翻译详解/e82f1dfe6d56.html","link":"","permalink":"https://linkfo.github.io/2023/08/03/%E7%BC%96%E7%A8%8B%E6%B8%A3%E6%B8%A3%E7%BF%BB%E8%AF%91%E8%AF%A6%E8%A7%A3/e82f1dfe6d56.html","excerpt":"介绍难以理解的渣渣翻译","text":"Handle 句柄的英文是 handle。在英文中，有操作、处理、控制之类的意义。作为一个名词时，是指某个中间媒介，通过这个中间媒介可控制、操作某样东西。 这样说有点抽象，举个例子。door handle 是指门把手，通过门把手可以去控制门，但 door handle 并非 door 本身，只是一个中间媒介。又比如 knife handle 是刀柄，通过刀柄可以使用刀。 跟 door handle 类似，我们可以用 file handle 去操作 file, 但 file handle 并非 file 本身。这个 file handle 就被翻译成文件句柄，同理还有各种资源句柄。 计算机领域很多英文词，直接从日常词中引申而来。比如 fork，日常用词就是个叉子，在 unix 中引申成创建新进程（进程分叉了）。socket 日常用词是插座（连起来用于通电），引申成联网的标记信息（连起来用于通信）。英文是很日常，很容易理解的词，有时翻译成中文反而难以理解了。 在 Windows 中，句柄是一种整数值，用于标识和访问系统对象或资源，如窗口、文件、设备等。 句柄充当了对象的唯一标识符，通过句柄可以对对象进行操作和管理。 Linux 中，句柄通常称为文件描述符（File Descriptor），它是一个非负整数，用于标识打开的文件、设备、管道等。 Linux将所有的I/O操作都抽象为文件，并使用文件描述符来引用和操作这些文件。 广义来说，指针也是某种 handle，可以操作对象。但实际语境中，指针跟句柄是有区别的。初次接触到 handle (或者 id)，很多人会有迷惑，为什么要用 handle，而不直接用指针呢？ 指针作用太强，可做的事情太多。可做的事情越多，就会越危险。接口设计中，功能刚刚好就够了，并非越多权限越好的。 handle 通常只是个整数，实现被隐藏起来，假如直接暴露了指针，也就暴露了指针类型（有时也可以暴露 void* 指针作为某种 handle）。用户看到越多细节，其代码就越有可能依赖这些细节。将来情况有变，但又要兼容用户代码，库内部改起来就更麻烦。 资源在内部管理，通过 handle 作为中间层，可以有效判断 handle 是否合法，也可以通过权限检查防止某种危险操作。 handle 通常只是个整数，所有的语言都有整数这种类型，但并非所有语言都有指针。接口只出现整数，方便同一实现绑定到各种语言。 句柄的引入主要是为了解决以下几个问题： 资源标识：操作系统中存在各种类型的资源，如窗口、文件、设备等。为了标识和引用这些资源，需要一种统一的方式。句柄提供了一个唯一的标识符，可以用于识别特定类型的资源。 封装和抽象：句柄将底层资源的具体实现进行了封装和抽象，提供了一种更高层次的接口供应用程序使用。这样，应用程序不需要了解资源的内部细节和底层实现，只需要通过句柄进行操作。 安全性和隔离：句柄可以充当一种权限验证的机制，通过句柄来访问资源可以进行权限检查，从而保证了资源的安全性。此外，句柄还可以实现资源的隔离，不同句柄之间的资源操作互不影响。 跨平台和兼容性：不同的操作系统和平台有各自的资源管理方式和实现，句柄提供了一种统一的方式来操作不同平台上的资源。这样，应用程序可以在不同的操作系统上运行，并使用相同的句柄接口来访问资源。 参考： https://www.zhihu.com/question/27656256/answer/943130123","categories":[{"name":"other","slug":"other","permalink":"https://linkfo.github.io/categories/other/"}],"tags":[{"name":"other","slug":"other","permalink":"https://linkfo.github.io/tags/other/"}]},{"title":"markdown语法","slug":"markdown语法","date":"2023-08-03T12:44:27.000Z","updated":"2023-08-03T12:46:44.569Z","comments":true,"path":"2023/08/03/markdown语法/2c6208d72ce7.html","link":"","permalink":"https://linkfo.github.io/2023/08/03/markdown%E8%AF%AD%E6%B3%95/2c6208d72ce7.html","excerpt":"markdown语法示例 Typora 操作","text":"Markdown介绍 Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。 Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。 Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。 Markdown 编写的文档后缀为 .md, .markdown。 常用快捷键 加粗： Ctrl + B 标题： Ctrl + H 插入链接： Ctrl + K 插入代码： Ctrl + Shift + C – 无法执行 行内代码： Ctrl + Shift + K 插入图片： Ctrl + Shift + I 无序列表：Ctrl + Shift + L – 无法执行 撤销： Ctrl + Z 一级标题： Ctrl + 1 – 以此类推 Typora快捷键整合 Ctrl+1 一阶标题 Ctrl+B 字体加粗 Ctrl+2 二阶标题 Ctrl+I 字体倾斜 Ctrl+3 三阶标题 Ctrl+U 下划线 Ctrl+4 四阶标题 Ctrl+Home 返回Typora顶部 Ctrl+5 五阶标题 Ctrl+End 返回Typora底部 Ctrl+6 六阶标题 Ctrl+T 创建表格 Ctrl+L 选中某句话 Ctrl+K 创建超链接 Ctrl+D 选中某个单词 Ctrl+F 搜索 Ctrl+E 选中相同格式的文字 Ctrl+H 搜索并替换 Alt+Shift+5 删除线 Ctrl+Shift+I 插入图片 Ctrl+Shift+M 公式块 Ctrl+Shift+Q 引用 ​ 注：一些实体符号需要在实体符号之前加”\\”才能够显示 块元素 换行符 在markdown中，段落由多个空格分隔。在Typora中，只需回车即可创建新段落。 标题级别 一级标题 快捷键为 Ctrl + 1 ## 二级标题 快捷键为 Ctrl + 2 … ###### 六级标题 快捷键为 Ctrl + 6 引用文字 空格 + 引用文字 无序列表 使用 * + - 都可以创建一个无序列表 AAA BBB CCC 有序列表 数字+英文 . +空格 使用 1. 2. 3. 创建有序列表 AAA BBB CCC 任务列表 \\ -[ ] 不勾选 \\ -[x] 勾选 代码块 在Typora中插入程序代码的方式有两种：使用反引号 `（~ 键）、使用缩进（Tab）。 插入行内代码，即插入一个单词或者一句代码的情况，使用 code 这样的形式插入。 插入多行代码输入3个反引号（`） + 回车，并在后面选择一个语言名称即可实现语法高亮。 def helloworld(): print(“hello, world!”) 数学表达式 当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。根据需要加载 Mathjax 对数学公式进行渲染。 按下 $$，然后按下回车键，即可进行数学公式的编辑。 V1×V2=X3\\mathbf{V}_1\\times\\mathbf{V}_2 = \\mathbf{X}_3 V​1​​×V​2​​=X​3​​ 插入表格 输入 | 表头1 | 表头2 |并回车。即可创建一个包含2列表。快捷键 Ctrl + T弹出对话框。 id number 不管是哪种方式，第一行为表头，第二行为分割表头和主体部分，第三行开始每一行为一个表格行 列与列之间用管道符号| 隔开 还可设置对齐方式(表头与内容之间)，如果不使用对齐标记，内容默认左对齐，表头居中对齐 左对齐 ：| 右对齐 |： 中对齐 ：|： 为了美观，可以使用空格对齐不同行的单元格，并在左右两侧都使用 | 来标记单元格边界 为了使 Markdown 更清晰，| 和 - 两侧需要至少有一个空格（最左侧和最右侧的 | 外就不需要了）。 脚注 这个例子的脚注为[1]。 注意：该例子脚注标识是1，脚注标识可以为字母数字下划线，但是暂不支持中文。脚注内容可为任意字符，包括中文。 分割线 输入 *** 或者 --- 再按回车即可绘制一条水平线，如下： 目录（TOC） 输入 [ toc ] 然后回车，即可创建一个“目录”。TOC从文档中提取所有标题，其内容将自动更新。 Typora支持TOC自动生成目录，博客园不支持？ 跨度元素 跨度元素即图片，网址，视频等，在Typora中输入后，会立即载入并呈现。 链接 内部链接 这是一个带有标题属性的 [链接](http://example.com/ &quot;标题&quot;) 这是一个没有标题属性的 [链接](http://example.net/) 链接 链接 参考链接 这是一个[参考链接]id – 无法执行 网址 Typora允许用&lt;括号括起来&gt;, 把URL作为链接插入。 Typora还会自动链接标准网址。 www.baidu.com 图片 除了以上2种方式之外，还可以直接将图片拖拽进来，自动生成链接。 斜体 使用 *单个星号* 或者 _单下划线_ 可以字体倾斜。快捷键 Ctrl + I 斜体 加粗 使用 **两个星号** 或者 __两个下划线__ 可以字体加粗。快捷键 Ctrl + B 加粗 加粗斜体 使用***加粗斜体***可以加粗斜体。 加粗斜体 代码标记 标记代码使用反引号，即在英文输入法下，ESC键下面和1键左边的符号。 使用该 printf()功能 删除线 使用~~删除线~~ 快捷键 Alt + Shift + 5 删除线 下划线 \\下划线 – 无法执行 参考另一篇文章，可执行。 通过&lt;u&gt;下划线的内容&lt;/u&gt; 或者 快捷键Ctrl + U可实现下划线 下划线的内容 表情符号 Github的Markdown语法支持添加emoji表情，输入不同的符号码（两个冒号包围的字符）可以显示出不同的表情。 :smile – 无法显示 😺 下标 可以使用 &lt;sub&gt;文本&lt;/sub&gt;实现下标。 (需在设置中打开该功能) H2O H2O 上标 可以使用&lt;sup&gt;文本&lt;/sup&gt;实现上标。 (需在设置中打开该功能) X2 X2 高亮 ==高亮==(需在设置中打开该功能) 我是最重要的 文本居中 使用 &lt;center&gt;这是要居中的内容&lt;/center&gt;可以使文本居中 这是要居中的文本内容 换行符 使用 空格 + 空格 + Enter可以实现换行，例如： 或者可以使用&lt;br/&gt;实现换行。 Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符： 文本加粗 ** 正常显示星号 ** Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号： \\ 反斜线 ` 反引号 星号 _ 下划线 {} 花括号 [] 方括号 () 小括号 井字号 加号 减号 . 英文句点 ! 感叹号 HTML 支持HTML 不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。 目前支持的 HTML 元素有：&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;等 ，如： 使用 Ctrl+Alt+Del 重启电脑 – 白色框框 效果： 使用 Ctrl+Alt+Del 重启电脑 嵌入内容 视频 总结 建议打开大纲视图Ctrl + Shift + 1 插入表格需要顶格写，否则无法显示 语法无须刻意记忆，右键可查询","categories":[{"name":"工具","slug":"工具","permalink":"https://linkfo.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://linkfo.github.io/tags/markdown/"}]},{"title":"VSCode各种设置 Default Settings(JSON)与Open User Settings与Open Workspace Settings(JSON)","slug":"VSCode各种设置","date":"2023-07-29T14:22:39.000Z","updated":"2023-07-29T14:46:20.605Z","comments":true,"path":"2023/07/29/VSCode各种设置/c787fc7e7f05.html","link":"","permalink":"https://linkfo.github.io/2023/07/29/VSCode%E5%90%84%E7%A7%8D%E8%AE%BE%E7%BD%AE/c787fc7e7f05.html","excerpt":"VSCode的配置设置","text":"VSCode中Default Settings(JSON)与Open User Settings与Open Workspace Settings(JSON) Preferences: Open Default Settings(JSON) 全局应用于打开的任何 VS Code 实例的设置 点击该选项，会出现defaultSettings.json文件，该文件至少有几千行，并且无法编辑，这个文件构成了VSCode及其扩展插件的基础配置，你可以在这个基础配置的基础上任意修改。 Preferences: Open User Settings 用户设置，用于自定义 VS Code 的个人设置，全局应用于打开的任何 VS Code 实例的设置。 Preferences: Open Workspace Settings(JSON) 存储在工作区内的设置，仅在打开工作区时应用。 点击该选项，会在当前工程目录下新建一个.vscode目录，在.vscode目录下，会多出一个settings.json文件，默认为空。 在这个settings.json文件中，可以写一些设置选项，这些设置选项仅仅对当前工程目录下的文件起作用。 工作区设置特定于项目，可以在项目的开发人员之间共享。工作区设置将覆盖用户设置。VS Code“工作区”通常只是项目根文件夹。工作区设置以及调试和任务配置存储在 .vscode 根目录下的文件夹中。 优先级 不同的设置范围可以在多个级别覆盖配置。在以下列表中，往下作用域将覆盖之上的作用域： Default settings - 默认设置 - 此范围表示默认的未配置设置值。 User settings - 用户设置 - 全局应用于所有 VS Code 实例。 Remote settings - 远程设置 - 应用于用户打开的远程计算机。 Workspace settings - 工作区设置 - 应用于打开的文件夹或工作区。 Workspace Folder settings - 工作区文件夹设置 - 应用于多根工作区的特定文件夹。 重置用户设置 将 VS Code 重置回默认设置的最简单方法是清除用户 settings.json 文件。使用命令面板中的首选项：打开用户设置 （JSON） 命令 （Ctrl+Shift+P） 打开 settings.json 文件。在编辑器中打开文件后，删除两个大括号之间的所有内容，保存文件 &#123;&#125; ，VS Code 将恢复使用默认值。","categories":[{"name":"工具","slug":"工具","permalink":"https://linkfo.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://linkfo.github.io/tags/%E5%B7%A5%E5%85%B7/"},{"name":"VSCode","slug":"VSCode","permalink":"https://linkfo.github.io/tags/VSCode/"}]},{"title":"强引用与弱引用","slug":"Java/强引用与弱引用","date":"2023-07-25T07:12:41.000Z","updated":"2023-08-03T13:25:45.609Z","comments":true,"path":"2023/07/25/Java/强引用与弱引用/d5ad512ffa75.html","link":"","permalink":"https://linkfo.github.io/2023/07/25/Java/%E5%BC%BA%E5%BC%95%E7%94%A8%E4%B8%8E%E5%BC%B1%E5%BC%95%E7%94%A8/d5ad512ffa75.html","excerpt":"各种程序语言的强弱应用","text":"强引用(Strong Reference) 强引用就是我们经常使用的引用 强引用最重要的就是它能够让引用变得强（Strong），这就决定了它和垃圾回收器的交互。具体来说，如果一个对象通过一串强引用链接可到达 (Strongly reachable)，它是不会被回收的。如果你不想让你正在使用的对象被回收，这就正是你所需要的 弱引用(WeakReference) 弱引用简单来说就是将对象留在内存的能力不是那么强的引用。使用WeakReference，垃圾回收器会帮你来决定引用的对象何时回收并且将对象从内存移除 引用《Java编程思想》中 ”每种编程语言都有自己的数据处理方式。有些时候，程序员必须注意将要处理的数据是什么类型。你是直接操纵元素，还是用某种基于特殊语法的间接表示（例如C/C++里的指针）来操作对象。所有这些在 Java 里都得到了简化，一切都被视为对象。因此，我们可采用一种统一的语法。尽管将一切都“看作”对象，但操纵的标识符实际是指向一个对象的“引用”（reference）。” python中的强引用和弱引用 弱引用（ weakref ） weakref.ref() 弱引用是一种特殊的对象，能够在不产生引用的前提下，关联目标对象。 from weakref import ref 弱引用对象的字段结构，定义于 Include/weakrefobject.h 头文件中的第 10-41 行： typedef struct _PyWeakReference PyWeakReference; /* PyWeakReference is the base struct for the Python ReferenceType, ProxyType, * and CallableProxyType. */ #ifndef Py_LIMITED_API struct _PyWeakReference &#123; PyObject_HEAD /* The object to which this is a weak reference, or Py_None if none. * Note that this is a stealth reference: wr_object's refcount is * not incremented to reflect this pointer. */ PyObject *wr_object; /* A callable to invoke when wr_object dies, or NULL if none. */ PyObject *wr_callback; /* A cache for wr_object's hash code. As usual for hashes, this is -1 * if the hash code isn't known yet. */ Py_hash_t hash; /* If wr_object is weakly referenced, wr_object has a doubly-linked NULL- * terminated list of weak references to it. These are the list pointers. * If wr_object goes away, wr_object is set to Py_None, and these pointers * have no meaning then. */ PyWeakReference *wr_prev; PyWeakReference *wr_next; &#125;; #endif wr_object ，对象指针，指向被引用对象，弱引用根据该字段可以找到被引用对象，但不会产生引用； wr_callback ，指向一个可调用对象，当被引用的对象销毁时将被调用； hash ，缓存被引用对象的哈希值； wr_prev 和 wr_next 分别是前后向指针，用于将弱引用对象组织成双向链表； 弱引用对象通过 wr_object 字段关联被引用的对象 一个对象可以同时被多个弱引用对象关联 所有关联同一个对象的弱引用，被组织成一个双向链表，链表头保存在被引用对象中 当一个对象被销毁后，Python 将遍历它的弱引用链表，逐一处理： 将 wr_object 字段设为 None ，弱引用对象再被调用将返回 None ，调用者便知道对象已经被销毁了； 执行回调函数 wr_callback （如有）；","categories":[{"name":"Java","slug":"Java","permalink":"https://linkfo.github.io/categories/Java/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://linkfo.github.io/tags/Python/"},{"name":"Java","slug":"Java","permalink":"https://linkfo.github.io/tags/Java/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://linkfo.github.io/tags/JavaScript/"}]},{"title":"Java 泛型","slug":"Java/Java 泛型","date":"2023-07-22T13:32:12.000Z","updated":"2023-08-03T13:25:38.344Z","comments":true,"path":"2023/07/22/Java/Java 泛型/9a6e0781ad45.html","link":"","permalink":"https://linkfo.github.io/2023/07/22/Java/Java%20%E6%B3%9B%E5%9E%8B/9a6e0781ad45.html","excerpt":"Java 泛型 来自https://www.cnblogs.com/coprince/p/8603492.html","text":"1. 概述 泛型在java中有很重要的地位，在面向对象编程及各种设计模式中有非常广泛的应用。 什么是泛型？为什么要使用泛型？ 泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？ 顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参）， 然后在使用/调用时传入具体的类型（类型实参）。 泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中， 操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。 2. 一个栗子 一个被举了无数次的例子： List arrayList = new ArrayList(); arrayList.add(“aaaa”); arrayList.add(100); for(int i = 0; i&lt; arrayList.size();i++){ String item = (String)arrayList.get(i); Log.d(“泛型测试”,&quot;item = &quot; + item); } 毫无疑问，程序的运行结果会以崩溃结束： java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String ArrayList可以存放任意类型，例子中添加了一个String类型，添加了一个Integer类型，再使用时都以String的方式使用，因此程序崩溃了。为了解决类似这样的问题（在编译阶段就可以解决），泛型应运而生。 我们将第一行声明初始化list的代码更改一下，编译器会在编译阶段就能够帮我们发现类似这样的问题。 List arrayList = new ArrayList(); … //arrayList.add(100); 在编译阶段，编译器就会报错 3. 特性 泛型只在编译阶段有效。看下面的代码： List stringArrayList = new ArrayList(); List integerArrayList = new ArrayList(); Class classStringArrayList = stringArrayList.getClass(); Class classIntegerArrayList = integerArrayList.getClass(); if(classStringArrayList.equals(classIntegerArrayList)){ Log.d(“泛型测试”,“类型相同”); } 输出结果：D/泛型测试: 类型相同。 通过上面的例子可以证明，在编译之后程序会采取去泛型化的措施。也就是说Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。 对此总结成一句话：泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型。 4. 泛型的使用 泛型有三种使用方式，分别为：泛型类、泛型接口、泛型方法 4.3 泛型类 泛型类型用于类的定义中，被称为泛型类。通过泛型可以完成对一组类的操作对外开放相同的接口。最典型的就是各种容器类，如：List、Set、Map。 泛型类的最基本写法（这么看可能会有点晕，会在下面的例子中详解）： class 类名称 &lt;泛型标识：可以随便写任意标识号，标识指定的泛型的类型&gt;{ private 泛型标识 /（成员变量类型）/ var; … } } 一个最普通的泛型类： //此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型 //在实例化泛型类时，必须指定T的具体类型 public class Generic{ //key这个成员变量的类型为T,T的类型由外部指定 private T key; public Generic(T key) &#123; //泛型构造方法形参key的类型也为T，T的类型由外部指定 this.key = key; &#125; public T getKey()&#123; //泛型方法getKey的返回值类型为T，T的类型由外部指定 return key; &#125; } //泛型的类型参数只能是类类型（包括自定义类），不能是简单类型 //传入的实参类型需与泛型的类型参数类型相同，即为Integer. Generic genericInteger = new Generic(123456); //传入的实参类型需与泛型的类型参数类型相同，即为String. Generic genericString = new Generic(“key_vlaue”); Log.d(“泛型测试”,&quot;key is &quot; + genericInteger.getKey()); Log.d(“泛型测试”,&quot;key is &quot; + genericString.getKey()); 12-27 09:20:04.432 13063-13063/? D/泛型测试: key is 123456 12-27 09:20:04.432 13063-13063/? D/泛型测试: key is key_vlaue 定义的泛型类，就一定要传入泛型类型实参么？并不是这样，在使用泛型的时候如果传入泛型实参，则会根据传入的泛型实参做相应的限制，此时泛型才会起到本应起到的限制作用。如果不传入泛型类型实参的话，在泛型类中使用泛型的方法或成员变量定义的类型可以为任何的类型。 看一个例子： Generic generic = new Generic(“111111”); Generic generic1 = new Generic(4444); Generic generic2 = new Generic(55.55); Generic generic3 = new Generic(false); Log.d(“泛型测试”,&quot;key is &quot; + generic.getKey()); Log.d(“泛型测试”,&quot;key is &quot; + generic1.getKey()); Log.d(“泛型测试”,&quot;key is &quot; + generic2.getKey()); Log.d(“泛型测试”,&quot;key is &quot; + generic3.getKey()); D/泛型测试: key is 111111 D/泛型测试: key is 4444 D/泛型测试: key is 55.55 D/泛型测试: key is false ** 注意：** 泛型的类型参数只能是类类型，不能是简单类型。 不能对确切的泛型类型使用instanceof操作。如下面的操作是非法的，编译时会出错。 if(ex_num instanceof Generic){ } 4.4 泛型接口 泛型接口与泛型类的定义及使用基本相同。泛型接口常被用在各种类的生产器中，可以看一个例子： //定义一个泛型接口 public interface Generator { public T next(); } 当实现泛型接口的类，未传入泛型实参时： /** 未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中 即：class FruitGenerator implements Generator{ 如果不声明泛型，如：class FruitGenerator implements Generator，编译器会报错：“Unknown class” */ class FruitGenerator implements Generator{ @Override public T next() { return null; } } 当实现泛型接口的类，传入泛型实参时： /** 传入泛型实参时： 定义一个生产器实现这个接口,虽然我们只创建了一个泛型接口Generator 但是我们可以为T传入无数个实参，形成无数种类型的Generator接口。 在实现类实现泛型接口时，如已将泛型类型传入实参类型，则所有使用泛型的地方都要替换成传入的实参类型 即：Generator，public T next();中的的T都要替换成传入的String类型。 */ public class FruitGenerator implements Generator { private String[] fruits = new String[]{“Apple”, “Banana”, “Pear”}; @Override public String next() { Random rand = new Random(); return fruits[rand.nextInt(3)]; } } 4.5 泛型通配符 我们知道Ingeter是Number的一个子类，同时在特性章节中我们也验证过Generic&lt;Ingeter&gt;与Generic&lt;Number&gt;实际上是相同的一种基本类型。那么问题来了，在使用Generic&lt;Number&gt;作为形参的方法中，能否使用Generic&lt;Ingeter&gt;的实例传入呢？在逻辑上类似于Generic&lt;Number&gt;和Generic&lt;Ingeter&gt;是否可以看成具有父子关系的泛型类型呢？ 为了弄清楚这个问题，我们使用Generic&lt;T&gt;这个泛型类继续看下面的例子： public void showKeyValue1(Generic obj){ Log.d(“泛型测试”,&quot;key value is &quot; + obj.getKey()); } Generic gInteger = new Generic(123); Generic gNumber = new Generic(456); showKeyValue(gNumber); // showKeyValue这个方法编译器会为我们报错：Generic&lt;java.lang.Integer&gt; // cannot be applied to Generic&lt;java.lang.Number&gt; // showKeyValue(gInteger); 通过提示信息我们可以看到Generic&lt;Integer&gt;不能被看作为`Generic&lt;Number&gt;的子类。由此可以看出:同一种泛型可以对应多个版本（因为参数类型是不确定的），不同版本的泛型类实例是不兼容的。 回到上面的例子，如何解决上面的问题？总不能为了定义一个新的方法来处理Generic&lt;Integer&gt;类型的类，这显然与java中的多台理念相违背。因此我们需要一个在逻辑上可以表示同时是Generic&lt;Integer&gt;和Generic&lt;Number&gt;父类的引用类型。由此类型通配符应运而生。 我们可以将上面的方法改一下： public void showKeyValue1(Generic&lt;?&gt; obj){ Log.d(“泛型测试”,&quot;key value is &quot; + obj.getKey()); } 类型通配符一般是使用？代替具体的类型实参，注意了，此处’？’是类型实参，而不是类型形参 。重要说三遍！此处’？’是类型实参，而不是类型形参 ！ 此处’？’是类型实参，而不是类型形参 ！再直白点的意思就是，此处的？和Number、String、Integer一样都是一种实际的类型，可以把？看成所有类型的父类。是一种真实的类型。 可以解决当具体类型不确定的时候，这个通配符就是 ? ；当操作类型时，不需要使用类型的具体功能时，只使用Object类中的功能。那么可以用 ? 通配符来表未知类型。 4.6 泛型方法 在java中,泛型类的定义非常简单，但是泛型方法就比较复杂了。 尤其是我们见到的大多数泛型类中的成员方法也都使用了泛型，有的甚至泛型类中也包含着泛型方法，这样在初学者中非常容易将泛型方法理解错了。 泛型类，是在实例化类的时候指明泛型的具体类型；泛型方法，是在调用方法的时候指明泛型的具体类型 。 /** 泛型方法的基本介绍 @param tClass 传入的泛型实参 @return T 返回值为T类型 说明： 1）public 与 返回值中间&lt;T&gt;非常重要，可以理解为声明此方法为泛型方法。 2）只有声明了&lt;T&gt;的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。 3）&lt;T&gt;表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。 4）与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。 */ public T genericMethod(Class tClass)throws InstantiationException , IllegalAccessException{ T instance = tClass.newInstance(); return instance; } Object obj = genericMethod(Class.forName(“com.test.test”)); 4.6.1 泛型方法的基本用法 光看上面的例子有的同学可能依然会非常迷糊，我们再通过一个例子，把我泛型方法再总结一下。 public class GenericTest { //这个类是个泛型类，在上面已经介绍过 public class Generic{ private T key; public Generic(T key) &#123; this.key = key; &#125; //我想说的其实是这个，虽然在方法中使用了泛型，但是这并不是一个泛型方法。 //这只是类中一个普通的成员方法，只不过他的返回值是在声明泛型类已经声明过的泛型。 //所以在这个方法中才可以继续使用 T 这个泛型。 public T getKey()&#123; return key; &#125; /** * 这个方法显然是有问题的，在编译器会给我们提示这样的错误信息&quot;cannot reslove symbol E&quot; * 因为在类的声明中并未声明泛型E，所以在使用E做形参和返回值类型时，编译器会无法识别。 public E setKey(E key)&#123; this.key = keu &#125; */ &#125; /** * 这才是一个真正的泛型方法。 * 首先在public与返回值之间的&lt;T&gt;必不可少，这表明这是一个泛型方法，并且声明了一个泛型T * 这个T可以出现在这个泛型方法的任意位置. * 泛型的数量也可以为任意多个 * 如：public &lt;T,K&gt; K showKeyName(Generic&lt;T&gt; container)&#123; * ... * &#125; */ public &lt;T&gt; T showKeyName(Generic&lt;T&gt; container)&#123; System.out.println(&quot;container key :&quot; + container.getKey()); //当然这个例子举的不太合适，只是为了说明泛型方法的特性。 T test = container.getKey(); return test; &#125; //这也不是一个泛型方法，这就是一个普通的方法，只是使用了Generic&lt;Number&gt;这个泛型类做形参而已。 public void showKeyValue1(Generic&lt;Number&gt; obj)&#123; Log.d(&quot;泛型测试&quot;,&quot;key value is &quot; + obj.getKey()); &#125; //这也不是一个泛型方法，这也是一个普通的方法，只不过使用了泛型通配符? //同时这也印证了泛型通配符章节所描述的，?是一种类型实参，可以看做为Number等所有类的父类 public void showKeyValue2(Generic&lt;?&gt; obj)&#123; Log.d(&quot;泛型测试&quot;,&quot;key value is &quot; + obj.getKey()); &#125; /** * 这个方法是有问题的，编译器会为我们提示错误信息：&quot;UnKnown class 'E' &quot; * 虽然我们声明了&lt;T&gt;,也表明了这是一个可以处理泛型的类型的泛型方法。 * 但是只声明了泛型类型T，并未声明泛型类型E，因此编译器并不知道该如何处理E这个类型。 public &lt;T&gt; T showKeyName(Generic&lt;E&gt; container)&#123; ... &#125; */ /** * 这个方法也是有问题的，编译器会为我们提示错误信息：&quot;UnKnown class 'T' &quot; * 对于编译器来说T这个类型并未项目中声明过，因此编译也不知道该如何编译这个类。 * 所以这也不是一个正确的泛型方法声明。 public void showkey(T genericObj)&#123; &#125; */ public static void main(String[] args) &#123; &#125; } 4.6.2 类中的泛型方法 当然这并不是泛型方法的全部，泛型方法可以出现杂任何地方和任何场景中使用。但是有一种情况是非常特殊的，当泛型方法出现在泛型类中时，我们再通过一个例子看一下 public class GenericFruit { class Fruit{ @Override public String toString() { return “fruit”; } } class Apple extends Fruit&#123; @Override public String toString() &#123; return &quot;apple&quot;; &#125; &#125; class Person&#123; @Override public String toString() &#123; return &quot;Person&quot;; &#125; &#125; class GenerateTest&lt;T&gt;&#123; public void show_1(T t)&#123; System.out.println(t.toString()); &#125; //在泛型类中声明了一个泛型方法，使用泛型E，这种泛型E可以为任意类型。可以类型与T相同，也可以不同。 //由于泛型方法在声明的时候会声明泛型&lt;E&gt;，因此即使在泛型类中并未声明泛型，编译器也能够正确识别泛型方法中识别的泛型。 public &lt;E&gt; void show_3(E t)&#123; System.out.println(t.toString()); &#125; //在泛型类中声明了一个泛型方法，使用泛型T，注意这个T是一种全新的类型，可以与泛型类中声明的T不是同一种类型。 public &lt;T&gt; void show_2(T t)&#123; System.out.println(t.toString()); &#125; &#125; public static void main(String[] args) &#123; Apple apple = new Apple(); Person person = new Person(); GenerateTest&lt;Fruit&gt; generateTest = new GenerateTest&lt;Fruit&gt;(); //apple是Fruit的子类，所以这里可以 generateTest.show_1(apple); //编译器会报错，因为泛型类型实参指定的是Fruit，而传入的实参类是Person //generateTest.show_1(person); //使用这两个方法都可以成功 generateTest.show_2(apple); generateTest.show_2(person); //使用这两个方法也都可以成功 generateTest.show_3(apple); generateTest.show_3(person); &#125; } 4.6.3 泛型方法与可变参数 再看一个泛型方法和可变参数的例子： public void printMsg( T… args){ for(T t : args){ Log.d(“泛型测试”,&quot;t is &quot; + t); } } printMsg(“111”,222,“aaaa”,“2323.4”,55.55); 4.6.4 静态方法与泛型 静态方法有一种情况需要注意一下，那就是在类中的静态方法使用泛型：静态方法无法访问类上定义的泛型；如果静态方法操作的引用数据类型不确定的时候，必须要将泛型定义在方法上。 即：如果静态方法要使用泛型的话，必须将静态方法也定义成泛型方法 。 public class StaticGenerator { … … /** * 如果在类中定义使用泛型的静态方法，需要添加额外的泛型声明（将这个方法定义成泛型方法） * 即使静态方法要使用泛型类中已经声明过的泛型也不可以。 * 如：public static void show(T t){…},此时编译器会提示错误信息： “StaticGenerator cannot be refrenced from static context” */ public static void show(T t){ &#125; } 4.6.5 泛型方法总结 泛型方法能使方法独立于类而产生变化，以下是一个基本的指导原则： 无论何时，如果你能做到，你就该尽量使用泛型方法。也就是说，如果使用泛型方法将整个类泛型化， 那么就应该使用泛型方法。另外对于一个static的方法而已，无法访问泛型类型的参数。 所以如果static方法要使用泛型能力，就必须使其成为泛型方法。 4.6 泛型上下边界 在使用泛型的时候，我们还可以为传入的泛型类型实参进行上下边界的限制，如：类型实参只准传入某种类型的父类或某种类型的子类。 为泛型添加上边界，即传入的类型实参必须是指定类型的子类型 public void showKeyValue1(Generic&lt;? extends Number&gt; obj){ Log.d(“泛型测试”,&quot;key value is &quot; + obj.getKey()); } Generic generic1 = new Generic(“11111”); Generic generic2 = new Generic(2222); Generic generic3 = new Generic(2.4f); Generic generic4 = new Generic(2.56); //这一行代码编译器会提示错误，因为String类型并不是Number类型的子类 //showKeyValue1(generic1); showKeyValue1(generic2); showKeyValue1(generic3); showKeyValue1(generic4); 如果我们把泛型类的定义也改一下: public class Generic{ private T key; public Generic(T key) &#123; this.key = key; &#125; public T getKey()&#123; return key; &#125; } //这一行代码也会报错，因为String不是Number的子类 Generic generic1 = new Generic(“11111”); 再来一个泛型方法的例子： //在泛型方法中添加上下边界限制的时候，必须在权限声明与返回值之间的上添加上下边界，即在泛型声明的时候添加 //public T showKeyName(Generic container)，编译器会报错：“Unexpected bound” public T showKeyName(Generic container){ System.out.println(“container key :” + container.getKey()); T test = container.getKey(); return test; } 通过上面的两个例子可以看出：泛型的上下边界添加，必须与泛型的声明在一起 。 4.7 关于泛型数组要提一下 看到了很多文章中都会提起泛型数组，经过查看sun的说明文档，在java中是”不能创建一个确切的泛型类型的数组”的。 也就是说下面的这个例子是不可以的： List[] ls = new ArrayList[10]; 而使用通配符创建泛型数组是可以的，如下面这个例子： List[] ls = new ArrayList[10]; 这样也是可以的： List[] ls = new ArrayList[10]; 下面使用Sun的一篇文档的一个例子来说明这个问题： List[] lsa = new List[10]; // Not really allowed. Object o = lsa; Object[] oa = (Object[]) o; List li = new ArrayList(); li.add(new Integer(3)); oa[1] = li; // Unsound, but passes run time store check String s = lsa[1].get(0); // Run-time error: ClassCastException. 这种情况下，由于JVM泛型的擦除机制，在运行时JVM是不知道泛型信息的，所以可以给oa[1]赋上一个ArrayList而不会出现异常， 但是在取出数据的时候却要做一次类型转换，所以就会出现ClassCastException，如果可以进行泛型数组的声明， 上面说的这种情况在编译期将不会出现任何的警告和错误，只有在运行时才会出错。 而对泛型数组的声明进行限制，对于这样的情况，可以在编译期提示代码有类型安全问题，比没有任何提示要强很多。 下面采用通配符的方式是被允许的:数组的类型不可以是类型变量，除非是采用通配符的方式，因为对于通配符的方式，最后取出数据是要做显式的类型转换的。 List[] lsa = new List[10]; // OK, array of unbounded wildcard type. Object o = lsa; Object[] oa = (Object[]) o; List li = new ArrayList(); li.add(new Integer(3)); oa[1] = li; // Correct. Integer i = (Integer) lsa[1].get(0); // OK 5. 最后 本文中的例子主要是为了阐述泛型中的一些思想而简单举出的，并不一定有着实际的可用性。另外，一提到泛型，相信大家用到最多的就是在集合中，其实，在实际的编程过程中，自己可以使用泛型去简化开发，且能很好的保证代码质量。","categories":[{"name":"Java","slug":"Java","permalink":"https://linkfo.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://linkfo.github.io/tags/Java/"},{"name":"基础","slug":"基础","permalink":"https://linkfo.github.io/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"VSCode插件推荐","slug":"VSCode插件推荐","date":"2023-07-22T07:51:12.000Z","updated":"2023-08-03T12:36:08.478Z","comments":true,"path":"2023/07/22/VSCode插件推荐/d3819720dbd9.html","link":"","permalink":"https://linkfo.github.io/2023/07/22/VSCode%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90/d3819720dbd9.html","excerpt":"插件推荐","text":"GitLens（git 操作插件） Markdown All in One Markdown Preview Enhanced Image preview（图片预览） filesize（文件大小） Git Graph（git 提交图形化展示） 驼峰翻译助手（变量名翻译） 别名路径跳转（代码路径跳转） Bookmarks（书签） Browse Lite（vscode 中的浏览器） Change Case（修改变量名风格） Comment Divider（分割线注释） DotENV（环境变量语法高亮） Live Sass Compiler（scss/sass 自动编译） Live Server（本地静态服务器） Random Something（中国特色的随机内容生成工具） Surround（代码片段包裹） Text Toolbox（文本工具箱） Text Toolbox（文本工具箱） VS Code Counter（字数统计） WindiCSS IntelliSense（windicss 工具） unocss（unocss 工具） Material Theme Material Icon Theme 数据库 mysql MongoDB oracle Codelf Prettier - Code formatter vscode-json Regex Previewer npm Intellisense Turbo Console Log css-auto-prefix CSS Peek Sort lines Data Preview LeetCode","categories":[{"name":"工具","slug":"工具","permalink":"https://linkfo.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://linkfo.github.io/tags/%E5%B7%A5%E5%85%B7/"},{"name":"vscode","slug":"vscode","permalink":"https://linkfo.github.io/tags/vscode/"}]},{"title":"python for data analysis","slug":"python for data analysis","date":"2023-07-21T13:30:06.000Z","updated":"2023-08-03T13:23:07.638Z","comments":true,"path":"2023/07/21/python for data analysis/18c165967132.html","link":"","permalink":"https://linkfo.github.io/2023/07/21/python%20for%20data%20analysis/18c165967132.html","excerpt":"为什么要做","text":"前期准备 conda 环境 conda create -n envte conda activate envte conda install -y pandas jupyter matplotlib conda install lxml beautifulsoup4 html5lib openpyxl requests sqlalchemy seaborn scipy statsmodels patsy scikit-learn pyarrow pytables numba conda remove --name env_name --all pandas matplotlib numpy scikit-learn scipy seaborn 约定命名 import numpy as np import matplotlib.pyplot as plt import pandas as pd import seaborn as sns import statsmodels as sm Python基础介绍 dir(math)可以使用dir查看模块所以方法 help()展示所有模块中所以方法的说明 导入模块 import xxxx from xxx import xxx from xxx import * 数学模块 math 日期时间模块 datetime 随机模块 random 文件操作模块 file 正则匹配模块 re 系统接口模块 sys 第三方库 Numpy是 Python 语言的一个扩展程序库，支持大量的维度数组与矩阵运算，此外也针对数组运算提供大量的数学函数库。 Scipy是一个用于数学、科学、工程领域的常用软件包，可以处理最优化、线性代数、积分、插值、拟合、特殊函数、快速傅里叶变换、信号处理、图像处理、常微分方程求解器等。 Matplotlib绘图领域使用最广泛的套件，它能让使用者很轻松地将数据图形化。 Pandas提供高性能、易于使用的数据结构和数据分析工具，可以对各种数据进行运算操作，比如归并、再成形、选择，还有数据清洗和数据加工特征。 Scikit-learn Python机器学习库，它广泛地用于统计分析和机器学习建模等数据科学领域。 OpenCV是一个开源的计算机视觉库，它提供了很多函数，这些函数非常高效地实现了计算机视觉算法。 NLTK是在处理预料库、分类文本、分析语言结构等多项操作中最长遇到的包。 Gensim是在做自然语言处理时较为经常用到的一个工具库，主要用来以无监督的方式从原始的非结构化文本当中来学习到文本隐藏层的主题向量表达。 主要包括TF-IDF，LSA，LDA，word2vec，doc2vec等多种模型。 NumPy NumPy是Numerical Python的缩写，是Python中最重要的数值计算基础包之一 NDarray，一个高效的多维阵列，提供快速的面向阵列的算术运算和灵活的_广播_功能 数学函数，无需编写循环即可对整个数据数组进行快速操作 用于将数组数据读/写到磁盘以及处理内存映射文件的工具 线性代数、随机数生成和傅里叶变换功能 一个C API，用于将NumPy与用C，C++或FORTRAN编写的库连接起来 data=np.array() #创建 data.shape #数组形状 data.dtype #数组属性 data.ndim #数组维度 #创建0或1的数组 np.ones(10) np.zeros(10) np.zeros((2,3,4))#传入一个元组构建多维矩阵 来源 `https://zhuanlan.zhihu.com/p/454916593` order参数的C和F是numpy中数组元素存储区域的两种排列格式，即C语言格式和Fortran语言格式。 一个三维数组 a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) int size 为 4 bytes 数组a在内存中的数据存储区域中存储方式(默认order=&quot;C&quot;，其中一个格子是4bytes)： |1|2|3|4|5|6|7|8|9| a.strides = (12, 4) 以F order创建数组： a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]],order=&quot;F&quot;) 数组b在内存中的数据存储区域中的存储方式： |1|4|7|2|5|8|3|6|9| a.strides = (4, 12) data=np.random.random(10) data.max() data.min() data.sum() data.dot() 点积运算 axis表示的是沿着哪一个轴的方向，axis本身是指数组的轴，在执行不同的函数时，具体的操作是沿着轴的方向进行的。axis的取值取决于数据的维度，如果数据是一维数组那么axis只有0，如果数据是二维的，那么axis可以取0和1，如果数据是三维的，那么axis就可以取0、1和2。 具体的，以常用的二维数据为例：axis=0表示跨行，axis=1表示跨列，作为方法动作的副词 axis=0表示沿着列的方向，做逐行的操作 axis=1表示沿着行的方向，做逐列的操作 转置 data.T 改变形状 data.reshape() 使用 ndarray 的方法 astype 将数组从一种数据类型显式转换或强制转换为另一种数据类型 arr = np.array([1, 2, 3, 4, 5]) arr.dtype dtype('int64') float_arr = arr.astype(np.float64)","categories":[{"name":"python","slug":"python","permalink":"https://linkfo.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://linkfo.github.io/tags/python/"},{"name":"DataAnalysis","slug":"DataAnalysis","permalink":"https://linkfo.github.io/tags/DataAnalysis/"}]},{"title":"git常用命令","slug":"git/git常用命令","date":"2023-07-21T13:27:56.000Z","updated":"2023-07-21T13:32:54.369Z","comments":true,"path":"2023/07/21/git/git常用命令/c48fdddbaf37.html","link":"","permalink":"https://linkfo.github.io/2023/07/21/git/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/c48fdddbaf37.html","excerpt":"为什么要做？","text":"github相关 git下载指定分支代码到本地 git clone -b 分支名 xxxx.git # git下载github所有分支代码到本地 git clone xxxxx.git 克隆远程仓库到本地 git branch -a 查看所有分支 绿色的表示本地当前分支 红色的表示远程的分支。 需要远程分支a中的文件。切换到指定分支即可； git checkout a","categories":[{"name":"工具","slug":"工具","permalink":"https://linkfo.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"git","slug":"git","permalink":"https://linkfo.github.io/tags/git/"},{"name":"github","slug":"github","permalink":"https://linkfo.github.io/tags/github/"}]},{"title":"index","slug":"index","date":"2023-07-21T13:21:20.000Z","updated":"2023-08-03T12:52:44.301Z","comments":true,"path":"2023/07/21/index/1f4aaaa4b735.html","link":"","permalink":"https://linkfo.github.io/2023/07/21/index/1f4aaaa4b735.html","excerpt":"索引","text":"2023 07 [[程序员延寿指南]] [[git]] [[conda 笔记]] [[python for data analysis]] [[VSCode插件推荐]] [[Java 泛型]] [[Python Cookbook]] [[强引用与弱引用]] [[VSCode各种设置]] [[markdown语法]] [[编程渣渣翻译详解]] 08","categories":[{"name":"index","slug":"index","permalink":"https://linkfo.github.io/categories/index/"}],"tags":[{"name":"index","slug":"index","permalink":"https://linkfo.github.io/tags/index/"}]},{"title":"git","slug":"git","date":"2023-07-21T13:21:20.000Z","updated":"2023-07-21T13:27:47.304Z","comments":true,"path":"2023/07/21/git/0d5c6854b4b9.html","link":"","permalink":"https://linkfo.github.io/2023/07/21/git/0d5c6854b4b9.html","excerpt":"Git总目录","text":"目录 [[git常用命令]] [[git add 的区别与联系]]","categories":[{"name":"工具","slug":"工具","permalink":"https://linkfo.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"index","slug":"index","permalink":"https://linkfo.github.io/tags/index/"},{"name":"git","slug":"git","permalink":"https://linkfo.github.io/tags/git/"}]},{"title":"git add .，git add -A，git add -u，git add * 的区别与联系","slug":"git/git add 的区别与联系","date":"2023-07-20T07:06:33.000Z","updated":"2023-07-21T13:33:44.395Z","comments":true,"path":"2023/07/20/git/git add 的区别与联系/bdb85a9a7f74.html","link":"","permalink":"https://linkfo.github.io/2023/07/20/git/git%20add%20%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB/bdb85a9a7f74.html","excerpt":"为什么要做？","text":"这几个命令在不同版本的 Git 中稍有差异。 对于 Git Version 1.x： git add .：会将当前工作区中当前目录(包括子目录)下的所有新文件和对已有文件的改动提交至暂存区，但不包括被删除的文件。 git add -u：git add --update 的简写形式，它只会监控当前整个工作区中之前已被 add 的文件，即已被跟踪(tracked)的文件，也就是只会将当前整个工作区中被修改和被删除的文件提交至暂存区。而新文件因为未被跟踪(untracked)，所以不会被提交至暂存区。 git add -A：git add --all 的简写形式，它会将当前整个工作区中所有的文件改动提交至暂存区，包括新增、修改和被删除的文件，不受当前所在目录限制。 注意：你会看到有些文章说 git add -A 属于 git add . 和 git add -u 功能的合集，这是不对的。因为 git add . 只会提交当前目录(包括子目录)下的新文件和对已有文件的改动，而 git add -A 不受当前目录限制。也就是说，git add . 和 git add -u 功能的合集只能属于 git add -A 功能的子集。 总结详见下图： Git Version 1.x 新文件 被修改的文件 被删除的文件 是否受当前所在目录限制 说明 git add -A. ✅ ✅ ✅ ❌ 将当前整个工作区中所有的文件改动提交至暂存区，包括新增、修改和被删除的文件，不受当前所在目录限制 git add . ✅ ✅ ❌ ✅ 将当前工作区中当前目录(包括子目录)下的所有新文件和对已有文件的改动提交至暂存区，但不包括被删除的文件 git add -u. ❌ ✅ ✅ ❌ 将当前整个工作区中被修改和被删除的文件提交至暂存区。而新文件因为未被跟踪(untracked)，所以不会被提交至暂存区 对于 Git Version 2.x： 在 Git --version 2.x 中对 git add . 的功能做了改动，git add . 会提交当前工作区中当前目录(包括子目录)下所有的文件改动，不像在 Git --version 1.x 时那样不包括被删除的文件。 Git Version 2.x 中如果想在使用 git add . 时不提交被删除的文件，可以使用 git add --ignore-removal 加上匹配符 .，即 git add --ignore-removal .。 git add --ignore-removal 后的匹配符是可以更换的(但不能缺省)，例如 git add --ignore-removal -A 可以实现在 git add -A 时不提交被删除的文件。 有些文章说在 Git --version 2.x 中 git add . 和 git add -A 的功能变得完全相同，这是不对的。因为我们之前提到过，git add . 提交的文件改动受当前所在目录限制，它只会提交当前工作区中当前目录(包括子目录)下的文件改动，而 git add -A 不受当前所在目录的限制，提交的是当前整个工作区中所有的文件改动。 git add * git add * 表示添加当前目录(包括子目录)下的所有文件改动，但不包括文件名以 . 符号开头的文件的改动。这是 Shell 命令，git 只是接收文件列表。而 git add . 的功能与 git add * 基本相同，只是 git add . 会将文件名以 . 符号开头的文件的改动也提交至暂存区。 总结详见下图： 总结详见下图： Git Version 2.x 新文件 被修改的文件 被删除的文件 是否受当前所在目录限制 说明 git add -A ✅ ✅ ✅ ❌ 将当前整个工作区中所有的文件改动提交至暂存区，包括新增、修改和被删除的文件，不受当前所在目录限制 git add . ✅ ✅ ✅ ✅ 将当前工作区中当前目录(包括子目录)下的所有的文件改动提交至暂存区，包括新增、修改和被删除的文件 git add -u. ❌ ✅ ✅ ❌ 将当前整个工作区中被修改和被删除的文件提交至暂存区。而新文件因为未被跟踪(untracked)，所以不会被提交至暂存区 git add * ✅ ✅ ✅ ✅ 将当前工作区中当前目录(包括子目录)下的所有的文件改动提交至暂存区，包括新增、修改和被删除的文件，但不包括文件名以 . 符号开头的文件的改动","categories":[{"name":"other","slug":"other","permalink":"https://linkfo.github.io/categories/other/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://linkfo.github.io/tags/%E5%B7%A5%E5%85%B7/"},{"name":"git","slug":"git","permalink":"https://linkfo.github.io/tags/git/"}]},{"title":"conda 笔记","slug":"conda 笔记","date":"2023-07-18T11:26:04.000Z","updated":"2023-08-03T12:36:56.413Z","comments":true,"path":"2023/07/18/conda 笔记/a55e79a55634.html","link":"","permalink":"https://linkfo.github.io/2023/07/18/conda%20%E7%AC%94%E8%AE%B0/a55e79a55634.html","excerpt":"为什么要做？","text":"conda conda命令的一些选项开关有两种指定方式，一种两个连接号“–”后跟选项名全程，一种是一个连接号“-”后跟简称。比如说&quot;-n&quot;和&quot;–name&quot;是等价的。但是要注意有些例外，比如说，“–version”对应的是“-V”（大写的V而不是小写的v） #查看conda版本 conda --version #查看conda的环境配置 conda config --show #设置镜像 conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/bioconda/ #设置bioconda conda config --add channels bioconda conda config --add channels conda-forge #设置搜索时显示通道地址 conda config --set show_channel_urls yes #更新conda conda update conda 查询某个命令的帮助 conda create --help 管理环境 Anaconda有一个缺省的名为base的环境。Conda允许你创建相互隔离的独立环境，这些环境被称之为虚拟环境（Virtual Environment） 创建虚拟环境 conda create -n env_name python=3.8 创建python版本为3.8、名字为env_name的虚拟环境，env_name文件可以在Anaconda安装目录envs文件下找到 查看有哪些虚拟环境 conda env list conda info -e conda info --envs 所显示的列表中，前面带星号“*“的表示当前活动环境 激活虚拟环境 conda activate env_name 退出虚拟环境 conda activate conda deactivate 以上两条命令只中任一条都会让你回到base environment 删除虚拟环境 conda env remove -n env_name --all conda remove --name env_name --all 如果只删除虚拟环境中的某个或者某些包则是： conda remove --name env_name package_name 导出环境 #获得环境中的所有配置 conda env export --name myenv &gt; myenv.yml #重新还原环境 conda env create -f myenv.yml 包（Package）的管理 查询看当前环境中安装了哪些包 conda list conda search package_name 在当前（虚拟）环境中安装一个包： conda install package_name conda install numpy=0.20.3 conda update numpy 安装包的时候可以指定从哪个channel进行安装，比如说，以下命令表示不是从缺省通道，而是从conda_forge安装某个包。 conda install pkg_name -c conda_forge conda卸载包 conda uninstall package_name conda uninstall package_name --force 清理anaconda缓存 conda clean -p # 删除没有用的包 --packages conda clean -t # 删除tar打包 --tarballs conda clean -y -all # 删除所有的安装包及cache(索引缓存、锁定文件、未使用过的包和tar包) Python版本的管理 将版本变更到指定版本 conda install python=3.5 python --version conda update python conda install vs pip install conda可以管理非python包，pip只能管理python包 conda configuration conda的配置文件为&quot;.condarc&quot;，该文件在安装时不是缺省存在的。但是当你第一次运行conda config命令时它就被自动创建了。&quot;.condarc&quot;配置文件遵循简单的YAML语法。 .condarc文件位置 执行conda info Channel管理 追加conda-forge channel: conda config --add channels conda-forge 移除conda-forge channel: conda config --remove channels conda-forge 查询当前配置中包含哪些channels conda config --get channels","categories":[{"name":"工具","slug":"工具","permalink":"https://linkfo.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://linkfo.github.io/tags/%E5%B7%A5%E5%85%B7/"},{"name":"Anaconda","slug":"Anaconda","permalink":"https://linkfo.github.io/tags/Anaconda/"},{"name":"conda","slug":"conda","permalink":"https://linkfo.github.io/tags/conda/"}]},{"title":"程序员延寿指南","slug":"程序员延寿指南","date":"2023-07-13T15:27:40.000Z","updated":"2023-07-21T13:44:23.087Z","comments":true,"path":"2023/07/13/程序员延寿指南/b6f5d6ace584.html","link":"","permalink":"https://linkfo.github.io/2023/07/13/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BB%B6%E5%AF%BF%E6%8C%87%E5%8D%97/b6f5d6ace584.html","excerpt":"程序员延寿指南","text":"来自于 [[git@github.com:geekan/HowToLiveLonger.git]] 1. 术语 ACM: All-Cause Mortality / 全因死亡率 2. 目标 稳健的活得更久 花更少时间工作：见MetaGPT 3. 关键结果 降低66.67%全因死亡率 增加~20年预期寿命 维持多巴胺于中轴 4. 分析 主要参考：对ACM的学术文献相对较多，可以作为主要参考 增加寿命与ACM关系非线性：显然增加寿命与ACM关系是非线性函数，这里假设 ΔLifeSpan=(1/(1+ΔACM)-1)*10（ΔACM为ACM变化值；公式欢迎优化） 变量无法简单叠加：显然各个变量之间并不符合独立同分布假设，变量之间的实际影响也并不明确 存在矛盾观点：所有的证据都有文献/研究对应，但注意到：有些文献之间有显著矛盾的观点（如对于碳水摄入比例的矛盾）；有些文献存在较大争议（如认为22点前睡觉会提升43%全因死亡率） 研究仅表达相关：所有文献表明的更多是相关而非因果，在阅读时要考虑文献是否充分证明了因果 —— 如某文献表明了日均&gt;=7000步的人有显著低的全因死亡率。但步数少的人可能包含更多长期病患，如果没有合理的排除这块数据，那此文献调查失真 5. 行动 输入 固体：吃白肉（-11%~-3% ACM）、蔬果为主（-26%~-17% ACM），多吃辣（-23% ACM），多吃坚果（-27%~-4% ACM），中量碳水、多吃植物蛋白（-10% ACM），少吃超加工食物（-62%~-18%） 液体：喝咖啡（-22%~-12% ACM），喝牛奶（-17%~-10% ACM），喝茶（-15%~-8% ACM），少喝或不喝甜味饮料（否则每天一杯+7% ACM，+多巴胺），戒酒或每周100g（纯酒精量(g)=饮酒量(ml)×酒精浓度(%)×酒精密度0.8g/ml）内（否则+~50% ACM，无上限） 气体：不吸烟（否则+~50% ACM，-12~-11年寿命） 光照：晒太阳（-~40% ACM） 药物：二甲双胍（糖尿病人相比正常人可以+3年）、复合维生素（-8%癌症风险）、亚精胺（-60%~-30% ACM）、葡萄糖胺（-39% ACM） 输出 运动：每周3次45分钟挥拍运动（-47% ACM） 日常：刷牙（-25% ACM） 睡眠：每天睡7小时全因死亡率最低；且22-24点间最好，早睡+43% ACM，晚睡+15% ACM（存在争议） 上下文 体重：减肥（-54% ACM） 6. 证据 6.1. 输入 6.1.1. 固体 白肉 JAMA子刊：食用红肉和加工肉类会增加心脏病和死亡风险！鱼肉和家禽肉则不会 出处：Associations of Processed Meat, Unprocessed Red Meat, Poultry, or Fish Intake With Incident Cardiovascular Disease and All-Cause Mortality 增加红肉摄入与死亡风险相关。八年内平均每天增加至少半份红肉摄入（半份红肉相当于14g加工红肉或40g非加工红肉）的调查对象，在接下来八年内全因死亡风险增加10％（HR, 1.10; 95%CI, 1.04-1.17）；每周吃两份红肉或加工肉类（但不包括家禽或鱼类）会使全因死亡风险增加3% 红肉和白肉最大的区别是什么？为啥要这么分呢？ 蔬果 每年54万人死亡，竟是因为水果吃得少！？这已成十大死亡因素之一！ 出处：Estimated Global, Regional, and National Cardiovascular Disease Burdens Related to Fruit and Vegetable Consumption: An Analysis from the Global Dietary Database (FS01-01-19) 每天摄入200克新鲜水果可使死亡率降低17%，糖尿病大血管并发症（如中风、缺血性心脏病等）风险降低13%，及糖尿病小血管并发症（如糖尿病肾病、糖尿病眼病、糖尿病足病等）风险降低28% 《自然》子刊：每天二两西兰花，健康长寿都有啦！分析近6万人23年的数据发现，吃含黄酮类食物与死亡风险降低20%相关丨临床大发现 出处：Flavonoid intake is associated with lower mortality in the Danish Diet Cancer and Health Cohort 吃含黄酮类食物与死亡风险降低20%相关 Bondonno博士说道“吃不同蔬菜、水果补充，不同种类的黄酮类化合物是很重要的，这很容易通过饮食实现：一杯茶、一个苹果、一个橘子、100克蓝莓，或100克西兰花，就能提供各种黄酮类化合物，并且总含量超过500毫克。 辣椒 辣椒成死亡克星？据调研，常吃辣患病死亡风险可降低61% 出处1：Chili pepper consumption and mortality in Italian adults 出处2：The Association of Hot Red Chili Pepper Consumption and Mortality: A Large Population-Based Cohort Study 2017年Plos One 的另一项来自美国的研究以16179名，年龄在18岁以上的人群为对象，并对其进行了高达19年的随访，发现在4946例死亡患者中，食用辣椒的参与者的全因死亡率为21.6％，而未食用辣椒的参与者的全因死亡率为33.6％。相较于不吃辣或很少吃（少于每周两次）的人群，每周吃辣＞4次的人群总死亡风险降低23%，心血管死亡风险降低34%。 鸡蛋 每天多吃半个蛋，增加7%的全因和心血管死亡风险？ 出处：NIH-AARP工作主页、Egg and cholesterol consumption and mortality from cardiovascular and different causes in the United States: A population-based cohort study 每天多吃半个蛋，增加7%的全因和心血管死亡风险？在假设性替代分析中，研究者发现，用等量的蛋清/鸡蛋替代物、家禽、鱼、乳制品、坚果和豆类分别替代半只全蛋（25克/天）可以降低6%、8%、9%、7%、13%和10%的全因死亡率。 *鸡蛋 坚果 哈佛20年研究：吃核桃的人更长寿，显著减少全因死亡，延长寿命 出处：Association of Walnut Consumption with Total and Cause-Specific Mortality and Life Expectancy in US Adults 通过分析发现，经常食用核桃可以延长寿命，降低心血管疾病死亡风险。比起不吃核桃，每周食用核桃5份以上（1份28克）的健康预期寿命延长1.3岁，全因死亡风险降低14%，心血管疾病死亡率降低25%。 研究：每日食生坚果，死亡率降20% 出处1：Association of nut consumption with total and cause-specific mortality 出处2：APG_Health-&amp;-Nutrition-Research-Brochure_DEC-19-18 研究人员发现，每周吃树坚果低于1盎司份量的人，死亡率降低7％。而每周吃了1盎司份量的人，减少11％的死亡率；每周吃2份量的人，减低13％；每周5至6份量者，减少了15％；一周7份以上的人，死亡率则减少20％。 另外两篇发表在《公共科学图书馆在线期刊》(Public Library of Science Online Journal)和《生物医学中心》(BioMed Central)上的医学预科研究论文，展示了试验开始时的横断面数据。这两项研究都评估了7,216名对象，以及他们食用坚果的频率和数量之间的关系。那些每周食用三份以上坚果(包括开心果)的研究对象的死亡率降低39%。 钠（存有大量争议） Eur Heart J：钠摄入量与预期寿命、全因死亡率的关系 出处：Messerli F H, Hofstetter L, Syrogiannouli L, et al. Sodium intake, life expectancy, and all-cause mortality[J]. European heart journal, 2021, 42(21): 2103-2112. 在该分析所包含的181个国家中，研究人员发现钠摄入量与出生时的健康预期寿命（β=2.6年/克每日钠摄入量，R2=0.66，P&lt;0.001）和60岁时的健康预期寿命（β=0.3年/克每日钠摄入量，R2=0.60，P=0.048）之间存在正相关关系，但与非传染性疾病死亡（β=17次事件/克每日钠摄入量，R2=0.43，P=0.100）无关。相反，全因死亡率与钠摄入量成负相关（β=−131次事件/克每日钠摄入量，R2=0.60，P&lt;0.001）。在仅限于46个收入最高国家的敏感性分析中，钠摄入量与出生时的健康预期寿命呈正相关（β=3.4年/克每日钠摄入量，R2=0.53，P&lt;0.001），而与全因死亡率（β=−168次事件/克每日钠摄入量，R2=0.50，P&lt;0.001）呈负相关。 该（大范围）研究认为更多的钠摄入与显著更低的全因死亡率有关 针对该论文的延伸解读和讨论：A Fresh Foray in the Salt Wars: Life Expectancy Higher With Greater Sodium Intake NEJM/Lancet：不要吃太多盐，中国饮食所致心血管病和癌症死亡全球第一，吃低钠盐可降低全因死亡率 但也有多项研究认为用低钠盐可以降低一系列疾病的发生概率，对全因死亡率的减少有积极影响 碳水（存有大量争议） 低碳生酮饮食（四）碳水化合物与长期死亡率 出处：The Lancet Public Health - Dietary carbohydrate intake and mortality: a prospective cohort study and meta-analysis 碳水越低，寿命越短；碳水越高，寿命也轻微缩短；碳水50%左右（其实按照一般的说法，这也算高碳水）是最长寿命区间 最强营养搭配！BMJ：这么吃，心血管疾病和死亡风险更低 槟榔 如何看待槟榔嚼出来的癌症？槟榔致癌风险究竟有多大？ - 丁香医生的回答 - 知乎 出处：Chewing Betel Quid and the Risk of Metabolic Disease, Cardiovascular Disease, and All-Cause Mortality: A Meta-Analysis(https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0070679) 嚼槟榔会增加21%的全因死亡率 热量限制 怎么看待BBC《进食、断食与长寿》？ 限制卡路里动物实验：CR（热量限制，即少吃）延迟了恒河猴的多种疾病发病和死亡率，与CR动物相比，正常喂养的猴子的各种疾病患病风险增加2.9倍，死亡风险增加3.0倍。 综合 最强营养搭配！BMJ：这么吃，心血管疾病和死亡风险更低 Associations of fat and carbohydrate intake with cardiovascular disease and mortality: prospective cohort study of UK Biobank participants 通过对这些参与者的数据进行分析，研究人员发现碳水化合物（糖、淀粉和纤维）和蛋白质的摄入与全因死亡率呈非线性关系，而脂肪则与全因死亡率呈线性相关。其中，较高的糖分摄入与全因死亡风险和患心血管疾病的风险较高均有关联，而较高的饱和脂肪酸摄入与全因死亡风险较高有关。 图1：各种营养元素与全因死亡之间的关系 图2：各种营养元素与心血管疾病之间的关系 进一步研究表明，在所有的饮食模式中，全因死亡率风险最低的饮食方式为：10-30g高纤维、14-30%蛋白质、10-25%单不饱和脂肪酸、5%-7%多不饱和脂肪酸以及20%-30%淀粉摄入。 最优能量来源配比：&lt;24%淀粉，15%-17%蛋白质，&gt;15%单不饱和脂肪酸，&lt;15%糖，6%饱和脂肪酸，6%多不饱和脂肪酸，30g+高纤维 BMJ | 常吃薯片汉堡巧克力等食品，平均死亡年龄仅仅为58岁，死亡风险剧增 Rico-Campà A, Martínez-González M A, Alvarez-Alvarez I, et al. Association between consumption of ultra-processed foods and all cause mortality: SUN prospective cohort study[J]. bmj, 2019, 365. Srour B, Fezeu L K, Kesse-Guyot E, et al. Ultra-processed food intake and risk of cardiovascular disease: prospective cohort study (NutriNet-Santé)[J]. bmj, 2019, 365. Lawrence M A, Baker P I. Ultra-processed food and adverse health outcomes[J]. bmj, 2019, 365. 6.1.2. 液体 牛奶 《柳叶刀》调研21个国家13万人：每天1斤牛奶或酸奶，心血管死亡风险下降23% 出处：Association of dairy intake with cardiovascular disease and mortality in 21 countries from five continents (PURE): a prospective cohort study 与不食用乳制品的人相比，每天摄入两份乳制品（一份指244克牛奶/酸奶，15克奶酪或5克黄油）的人，全因死亡风险下降了17%，心血管死亡风险下降23%，中风风险下降33% 茶 10万中国人随访7年发现，每周喝三次茶与全因死亡风险降低15%，预期寿命增加1.26年相关 出处：Tea consumption and the risk of atherosclerotic cardiovascular disease and all-cause mortality: The China-PAR project 中国成年人饮茶与死亡风险的前瞻性关联研究 纳入分析的438 443例研究对象随访11.1年共发生死亡34 661例。与从不饮茶者相比，当前非每日饮茶者和每日饮茶者全因死亡HR值（95%CI）依次为0.89（0.86-0.91）和0.92（0.88-0.95）。分性别分析显示，饮茶对全因死亡风险的保护作用主要见于男性（交互P&lt;0.05） 无糖（甜味）饮料 「无糖饮料使死亡风险增加 26 %」，是真的吗？ 相比于软饮料摄入量＜1杯/月的参与者，混合软饮料摄入≥1杯/天的参与者死亡风险增加18%，而摄入含糖软饮料或无糖软饮料会令死亡风险分别增加11%和27%。 Association Between Soft Drink Consumption and Mortality in 10 European Countries 有糖饮料 可乐和奶茶，增加全因死亡率高达62%！果汁降低免疫力，影响肝代谢！含糖饮料那些事 每天1杯含糖饮料增加7%全因死亡率，2杯21% 在34年的随访中，研究人员发现，相比那些一个月喝1杯或者更少含糖饮料的人，每天喝2杯的人总体死亡风险升高了21%，心血管疾病死亡风险升高了31%，癌症死亡风险上升了16%。 只要每天多喝一杯含糖饮料，总体死亡风险将增加7%，心血管疾病的风险将增加10%，癌症相关的死亡风险将16%。 发表在国际顶级期刊《BMJ》上的一篇论文就证明了含糖饮料会在增加患癌风险，当然这篇文章验证的不仅仅是果汁，奶茶也有份——和含糖饮料相关的总体患癌风险要高出通常值18%，100%的鲜榨果汁也会使得整体的患癌风险上升12%。 果汁 JAMA子刊：100%纯果汁可能比含糖饮料更危险 每天多摄入一份12盎司的含糖饮料，全因死亡率风险增加11%； 每天多摄入一份12盎司的果汁，全因死亡率风险增加24%。 咖啡 重磅！多篇研究证实喝咖啡与人群全因死亡率降低直接相关 科普 | 喝咖啡又多了一个新理由：降低死亡率！ 地中海成年人咖啡消耗量及全因，心血管疾病和癌症的死亡率 在最近的荟萃分析中，该研究包括来自不同国家的40项研究和3,852,651名受试者。在这项荟萃分析显示，咖啡摄入量与各种原因的死亡率，CVD和癌症死亡率之间存在非线性关系，每天摄入两杯咖啡的癌症死亡率最低(RR = 0.96)，CVD最低的死亡率，每天2.5杯(RR= 0.83)，全天最低死亡率为每天3.5杯(RR= 0.85)，并且随着咖啡消费量的增加，死亡率没有进一步降低或增加 亚精胺 Science：科学背书！从精液中发现的亚精胺，竟然有着抗衰老、抗癌、保护心血管和神经、改善肥胖和2型糖尿病等逆天神效 饮食中亚精胺摄入量高会降低死亡率 6.1.3. 气体 吸烟 即使是低强度吸烟，也增加死亡风险！ 研究发现：在42 416名男性和86 735名女性（年龄在35-89岁之间，以前没有患病）中，18 985名男性（45%）和18 072名女性（21%）目前吸烟，其中33%的男性吸烟者和39%的女性吸烟者并不每天吸烟。8866名男性（21%）和53 912名女性（62%）从不吸烟。在随访期间，与从不吸烟相比，每天&lt;10支烟或每天≥10支烟的全因死亡率危险比分别为1.17（95%置信区间1.10-1.25）和1.54（1.42-1.67）。无论年龄或性别，危险比相似。与每日吸烟关系最密切的疾病是呼吸道癌症、慢性阻塞性肺病和胃肠道及血管疾病。在招募时已经戒烟的人的死亡率低于现在每天吸烟者。 吸烟者平均减少寿命11-12年 吸烟让人过瘾是什么原理？有节制的吸烟依旧有害吗？ 6.1.4. 光照 晒太阳 晒太阳和死亡率的关系，如何科学，安全的晒太阳？ 丹麦一项长达26年的研究发现，多晒太阳能显著延长寿命，即使是由于过度暴晒诱发皮肤癌的患者，平均寿命也比普通人长了6岁。 6.1.5. 药物 NMN 二甲双胍 “胍”吹必看 丨我就是神药——二甲双胍 二甲双胍不仅在多种肿瘤、心血管疾病及糖尿病中发挥保护作用，而且在肥胖、肝病、肾病及衰老方面也大放异彩。 二甲双胍2020最值得了解的“吃瓜”大新闻——护胃、健脑、抗衰、防癌还是致癌？ 二甲双胍真的那么神吗？美研究：父亲服用二甲双胍或致子女有缺陷 不良反应 作为一种使用近百年的药物，二甲双胍的不良反应已经非常明确，常见的有：维生素B12缺乏（7%-17.4%），胃肠道不良反应（最高53%），疲倦（9%），头痛（6%）；严重但不常见的不良反应包括乳酸酸中毒、肝损伤；也有研究表明可能对胎儿致畸 复合维生素 服用复合维生素可降低癌症危险8%，其他效果并不显著 葡萄糖胺 神奇！氨糖降低心血管死亡率65%，与定期运动效果相当 美国西弗吉尼亚大学最新研究发现 氨糖（软骨素） 可以降低心血管死亡率65%，降低总体死亡率39%，效果与坚持定期运动相对 该研究使用1999年至2010年，16,686名成年人的国家健康和营养检查(NHANES)数据，参与者的中位追踪时间为107个月，而其中有648位参与者定期且每服用日500-1000毫克的葡萄糖胺/软骨素一年以上。 亚精胺 Science：科学背书！从精液中发现的亚精胺，竟然有着抗衰老、抗癌、保护心血管和神经、改善肥胖和2型糖尿病等逆天神效 亚精胺是最容易从人体肠道吸收的多胺。许多的食物中都含有大量的亚精胺，例如新鲜的青椒、小麦胚芽、花椰菜、西兰花、蘑菇和各种奶酪，尤其在纳豆等大豆制品、香菇和榴莲中含量更高。在本实验中，研究人员选择了829位年龄在45-84岁之间的参与者进行了为期20年的随访，分析了饮食中亚精胺摄入量与人类死亡率之间的潜在关联。 研究发现，女性的亚精胺摄入量高于男性，并且摄入量都会随着年龄的增长而下降。亚精胺的主要来源是全谷物（占13.4%）、苹果和梨（占13.3%）、沙拉（占9.8%）、芽菜（占7.3%）和马铃薯（占6.4%）。研究根据亚精胺摄入量将人群分为三组，低摄入量组（&lt;62.2 µmol / d）、中摄入量组（62.2–79.8 µmol / d）和高摄入量组（&gt; 79.8 µmol / d）。随访期间共记录了341例死亡，其中血管疾病137例，癌症94例，其他原因110例。经计算低中高三组的粗略死亡率分别为40.5%、23.7%和15.1%，这些数据表明亚精胺摄入量与全因死亡率之间的负相关关系显著。随着逐步对年龄、性别和热量的比例进行调整，这种相关关系依然显著。 综合 《自然》子刊深度综述：如何开发抗衰老药 6.2. 输出 6.2.1. 挥拍运动 哪种运动性价比最高？权威医学杂志“柳叶刀”给出答案了 一周三次，每次45-60分钟，挥拍运动，降低~47%全因死亡率 羽毛球、乒乓球、网球等都算挥拍运动，但由于西化研究背景，可能指网球更多。这隐式的表达了全身锻炼更为重要 6.2.2. 剧烈运动 新研究：每天剧烈运动8分钟，可降低全因死亡和心脏病风险 每周15-20分钟的剧烈运动，降低16-40%的全因死亡率，剧烈运动时间达到50-57分钟/周，可以进一步降低全因死亡率。这些发现表明，通过在一周的短时间内累积相对少量的剧烈运动可以降低健康风险。 6.2.3. 走路 走路降低全因死亡率超过50%！每天走多少步最合适？《JAMA》子刊超10年研究告诉你答案 注1：这项研究参与者的平均年龄为45.2岁 注2：平均步数的多少与职业有关，此项研究仅表明相关性，还没有更深度的因果分析 6.2.4. 刷牙 50万国人研究证实：不好好刷牙，致癌！血管疾病也会增多！ 经常不刷牙的人：癌症、慢性阻塞性肺病及肝硬化风险分别增加了9%、12%和25%，过早死亡风险增加25%。 6.2.5. 泡澡 定期洗澡降低心血管疾病发作风险 与每周一至两次泡澡或根本不泡澡相比，每天洗热水澡可以降低28%的心血管疾病总风险，降低26%的中风总风险，脑出血风险下降46%。而浴缸浴的频率与心源性猝死的风险增加无关。 6.2.6. 做家务（老年男性） Housework Reduces All-Cause and Cancer Mortality in Chinese Men 72岁之后男性每周做重型家务可以减少29%平均死亡率 重型家务：吸尘、擦地板、拖地、擦洗窗户、洗车、搬动家具、搬煤气罐等等。 轻型家务：掸灰尘、洗碗、手洗衣服、熨烫、晾衣服、做饭、买日用品等等。 6.2.7. 睡眠 超30万亚洲人数据：每天睡几个小时最有益长寿？ 在男性中，与睡眠时长为7小时相比：睡眠持续时间≥10小时与全因死亡风险增加34%相关； 在女性中，与睡眠持续时间7小时相比：睡眠持续时间≥10小时与全因死亡风险增加48%相关； 颠覆认知！加拿大研究发现：早睡比熬夜或许更伤身，几点睡才好？ 其中一个结论为，就寝时间与全因死亡率的关联性强，过早睡觉和过晚睡觉都会影响健康，但是早睡增加的全因死亡率比晚睡增加的死亡率高，早睡增加了43%的死亡风险，而晚睡增加了15%的死亡风险。 这项调查研究，还存在很多局限性，比如没有直接证明就寝时间与死亡的关系，仅仅说明相关性，通过参与人群自我报告统计睡眠时间，数据不够客观 6.2.8. 久坐 中国居民膳食指南科学研究报告（2021年） 久坐和看电视时间与全因死亡、心血管疾病、癌症和2型糖尿病发病高风险相关，是独立风险因素。久坐时间每天每增加1小时，心血管疾病发生风险增加4%，癌症增加1%，全因死亡风险增加3%。全因死亡和CVD死亡风险增加的久坐时间阈值是6~8h/d，看电视时间阈值是3~4h/d。 世卫组织关于身体活动和久坐行为的指南 6.3. 上下文 6.3.1. 情绪 悲观情绪与更高的全因死亡率和心血管疾病死亡率有关，但乐观情绪并不能起到保护作用 Pessimism is associated with greater all-cause and cardiovascular mortality, but optimism is not protective 在1993-1995年间，一项针对50岁以上澳大利亚人健康的双胞胎研究中包括了生活取向测试（LOT），其中包含乐观和悲观的项目。平均20年后，参与者与来自澳大利亚国家死亡指数的死亡信息相匹配。在2,978名具有很多可用分数的参与者中，有1,068人死亡。生存分析测试了各种乐观因素和悲观情绪分数与任何原因，癌症，心血管疾病或其他已知原因的死亡率之间的关联。年龄调整后的悲观量表上的核心与全因和心血管疾病死亡率相关（每1个标准差单位的危险比，95％置信区间和p值1.134、1.065–1.207、8.85×10 –5和1.196、1.045–1.368、0.0093 ），但不会因癌症死亡。乐观得分与悲观得分之间的相关性很弱（年龄调整后的等级相关系数= − 0.176），但与总死亡率或特定原因死亡率没有显着相关性。反向因果关系（引起悲观情绪的疾病）是不可能的，因为在那种情况下，心血管疾病和癌症都会导致悲观情绪。 6.3.2. 贫富 JAMA子刊：贫富差距真能影响寿命？这可能是真的！ 该研究使用1994-1996年第一次收集的数据，并通过生存模型来分析净资产和长寿之间的关联。结果显示，共收纳5414 名参与者，平均年龄为 46.7岁，包括 2766 名女性。较高的净资产与较低的死亡风险相关。特别是在兄弟姐妹和双胞胎中（n = 2490），在较高的净资产和较低的死亡率之间观察到类似的关联，表明拥有更多财富的兄弟姐妹或双胞胎比拥有更少财富的兄弟姐妹/双胞胎活得更久。 6.3.3. 体重 JAMA子刊：减肥要趁早，才能有效降低死亡率风险 对体重减轻的死亡率风险评估发现，体重从肥胖减轻到超重的成年人与稳定肥胖人群相比，全因死亡率降低了54％（危险比为0.46），然而从成年初期的超重减轻到中年以前的正常体重的人群的死亡率风险并未降低（风险比为1.12）。 6.3.4. 新冠 Magnitude, demographics and dynamics of the effect of the first wave of the COVID-19 pandemic on all-cause mortality in 21 industrialized countries 目前来看，新冠死亡率（美国）在1.5%左右，人均预期寿命减少了2年 如何看待美国CDC宣称新冠死亡人数被高估？ NVSS deaths","categories":[{"name":"other","slug":"other","permalink":"https://linkfo.github.io/categories/other/"}],"tags":[{"name":"other","slug":"other","permalink":"https://linkfo.github.io/tags/other/"}]}],"categories":[{"name":"other","slug":"other","permalink":"https://linkfo.github.io/categories/other/"},{"name":"工具","slug":"工具","permalink":"https://linkfo.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"Java","slug":"Java","permalink":"https://linkfo.github.io/categories/Java/"},{"name":"python","slug":"python","permalink":"https://linkfo.github.io/categories/python/"},{"name":"index","slug":"index","permalink":"https://linkfo.github.io/categories/index/"}],"tags":[{"name":"other","slug":"other","permalink":"https://linkfo.github.io/tags/other/"},{"name":"markdown","slug":"markdown","permalink":"https://linkfo.github.io/tags/markdown/"},{"name":"工具","slug":"工具","permalink":"https://linkfo.github.io/tags/%E5%B7%A5%E5%85%B7/"},{"name":"VSCode","slug":"VSCode","permalink":"https://linkfo.github.io/tags/VSCode/"},{"name":"Python","slug":"Python","permalink":"https://linkfo.github.io/tags/Python/"},{"name":"Java","slug":"Java","permalink":"https://linkfo.github.io/tags/Java/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://linkfo.github.io/tags/JavaScript/"},{"name":"基础","slug":"基础","permalink":"https://linkfo.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"vscode","slug":"vscode","permalink":"https://linkfo.github.io/tags/vscode/"},{"name":"python","slug":"python","permalink":"https://linkfo.github.io/tags/python/"},{"name":"DataAnalysis","slug":"DataAnalysis","permalink":"https://linkfo.github.io/tags/DataAnalysis/"},{"name":"git","slug":"git","permalink":"https://linkfo.github.io/tags/git/"},{"name":"github","slug":"github","permalink":"https://linkfo.github.io/tags/github/"},{"name":"index","slug":"index","permalink":"https://linkfo.github.io/tags/index/"},{"name":"Anaconda","slug":"Anaconda","permalink":"https://linkfo.github.io/tags/Anaconda/"},{"name":"conda","slug":"conda","permalink":"https://linkfo.github.io/tags/conda/"}]}